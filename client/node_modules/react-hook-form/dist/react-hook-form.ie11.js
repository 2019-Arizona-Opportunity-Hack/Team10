'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var isCheckBoxInput = (function (type) { return type === 'checkbox'; });

var VALIDATION_MODE = {
    onBlur: 'onBlur',
    onChange: 'onChange',
    onSubmit: 'onSubmit',
};
var RADIO_INPUT = 'radio';
var REQUIRED_ATTRIBUTE = 'required';
var PATTERN_ATTRIBUTE = 'pattern';
var UNDEFINED = 'undefined';
var EVENTS = {
    BLUR: 'blur',
    CHANGE: 'change',
    INPUT: 'input',
};

function attachEventListeners(_a) {
    var field = _a.field, validateAndStateUpdate = _a.validateAndStateUpdate, isRadio = _a.isRadio, isOnBlur = _a.isOnBlur, isReValidateOnBlur = _a.isReValidateOnBlur;
    var ref = field.ref;
    if (!ref.addEventListener)
        return;
    ref.addEventListener(isCheckBoxInput(ref.type) || isRadio ? EVENTS.CHANGE : EVENTS.INPUT, validateAndStateUpdate);
    if (isOnBlur || isReValidateOnBlur)
        ref.addEventListener(EVENTS.BLUR, validateAndStateUpdate);
}

var isUndefined = (function (val) { return val === undefined; });

var isNullOrUndefined = (function (value) {
    return value === null || isUndefined(value);
});

var isArray = (function (value) { return Array.isArray(value); });

var isObject = (function (value) {
    return !isNullOrUndefined(value) && !isArray(value) && typeof value === 'object';
});

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value) {
    return reIsUint.test(value) && value > -1;
}
function isKey(value) {
    if (isArray(value))
        return false;
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value);
}
var stringToPath = function (string) {
    var result = [];
    string.replace(rePropName, function (match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
};
function set(object, path, value) {
    var index = -1;
    var tempPath = isKey(path) ? [path] : stringToPath(path);
    var length = tempPath.length;
    var lastIndex = length - 1;
    while (++index < length) {
        var key = tempPath[index];
        var newValue = value;
        if (index !== lastIndex) {
            var objValue = object[key];
            newValue =
                isObject(objValue) || isArray(objValue)
                    ? objValue
                    : isIndex(tempPath[index + 1])
                        ? []
                        : {};
        }
        object[key] = newValue;
        object = object[key];
    }
    return object;
}

var combineFieldValues = (function (data) {
    return Object.entries(data).reduce(function (previous, _a) {
        var _b;
        var _c = __read(_a, 2), key = _c[0], value = _c[1];
        if (!!key.match(/\[.+\]/gi) || key.indexOf('.') > 0) {
            set(previous, key, value);
            return previous;
        }
        return __assign(__assign({}, previous), (_b = {}, _b[key] = value, _b));
    }, {});
});

var removeAllEventListeners = (function (ref, validateWithStateUpdate) {
    if (!ref.removeEventListener)
        return;
    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);
    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);
    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);
});

var isRadioInput = (function (type) { return type === RADIO_INPUT; });

function isDetached(element) {
    if (!element)
        return true;
    if (!(element instanceof HTMLElement) ||
        element.nodeType === Node.DOCUMENT_NODE)
        return false;
    return isDetached(element.parentNode);
}

function findRemovedFieldAndRemoveListener(fields, validateWithStateUpdate, field, forceDelete) {
    if (validateWithStateUpdate === void 0) { validateWithStateUpdate = function () { }; }
    if (forceDelete === void 0) { forceDelete = false; }
    if (!field)
        return;
    var ref = field.ref, mutationWatcher = field.mutationWatcher, options = field.options;
    if (!ref || !ref.type)
        return;
    var name = ref.name, type = ref.type;
    if (isRadioInput(type) && options) {
        options.forEach(function (_a, index) {
            var ref = _a.ref;
            if ((options[index] && isDetached(ref)) || forceDelete) {
                removeAllEventListeners(options[index], validateWithStateUpdate);
                (options[index].mutationWatcher || { disconnect: function () { } }).disconnect();
                options.splice(index, 1);
            }
        });
        if (!options.length)
            delete fields[name];
    }
    else if (isDetached(ref) || forceDelete) {
        removeAllEventListeners(ref, validateWithStateUpdate);
        if (mutationWatcher)
            mutationWatcher.disconnect();
        delete fields[name];
    }
}

var defaultReturn = {
    isValid: false,
    value: '',
};
var getRadioValue = (function (options) {
    return isArray(options)
        ? options.reduce(function (previous, _a) {
            var _b = _a.ref, checked = _b.checked, value = _b.value;
            return checked
                ? {
                    isValid: true,
                    value: value,
                }
                : previous;
        }, defaultReturn)
        : defaultReturn;
});

var getMultipleSelectValue = (function (options) {
    return __spread(options).filter(function (_a) {
        var selected = _a.selected;
        return selected;
    })
        .map(function (_a) {
        var value = _a.value;
        return value;
    });
});

var isMultipleSelect = (function (type) { return type === 'select-multiple'; });

function getFieldValue(fields, ref) {
    var type = ref.type, name = ref.name, options = ref.options, checked = ref.checked, value = ref.value, files = ref.files;
    if (type === 'file') {
        return files;
    }
    if (isRadioInput(type)) {
        var field = fields[name];
        return field ? getRadioValue(field.options).value : '';
    }
    if (isMultipleSelect(type))
        return getMultipleSelectValue(options);
    if (isCheckBoxInput(type)) {
        if (checked) {
            return ref.attributes && ref.attributes.value
                ? isUndefined(value) || value === ''
                    ? true
                    : value
                : true;
        }
        return false;
    }
    return value;
}

var getFieldsValues = (function (fields) {
    return Object.values(fields).reduce(function (previous, _a) {
        var _b;
        var ref = _a.ref, name = _a.ref.name;
        return (__assign(__assign({}, previous), (_b = {}, _b[name] = getFieldValue(fields, ref), _b)));
    }, {});
});

var isEmptyObject = (function (value) {
    return isObject(value) && Object.keys(value).length === 0;
});

var isSameError = (function (error, type, message) {
    return isObject(error) && (error.type === type && error.message === message);
});

// TODO: improve the types in this file
function shouldUpdateWithError(_a) {
    var errors = _a.errors, name = _a.name, error = _a.error, validFields = _a.validFields, fieldsWithValidation = _a.fieldsWithValidation;
    if ((validFields.has(name) && isEmptyObject(error)) ||
        (errors[name] && errors[name].isManual)) {
        return false;
    }
    if ((fieldsWithValidation.has(name) &&
        !validFields.has(name) &&
        isEmptyObject(error)) ||
        (isEmptyObject(errors) && !isEmptyObject(error)) ||
        (isEmptyObject(error) && errors[name]) ||
        !errors[name]) {
        return true;
    }
    return (errors[name] &&
        error[name] &&
        !isSameError(errors[name], error[name].type, error[name].message));
}

var isRegex = (function (value) { return value instanceof RegExp; });

var getValueAndMessage = (function (validationData) { return ({
    value: isObject(validationData) && !isRegex(validationData)
        ? validationData.value
        : validationData,
    message: isObject(validationData) && !isRegex(validationData)
        ? validationData.message
        : '',
}); });

var isString = (function (value) { return typeof value === 'string'; });

var displayNativeError = (function (nativeValidation, ref, message) {
    if (nativeValidation && isString(message))
        ref.setCustomValidity(message);
});

var isFunction = (function (value) {
    return typeof value === 'function';
});

var isBoolean = (function (value) { return typeof value === 'boolean'; });

function getValidateFunctionErrorObject(result, ref, nativeError, type) {
    if (type === void 0) { type = 'validate'; }
    var isStringValue = isString(result);
    if (isStringValue || (isBoolean(result) && !result)) {
        var message = isStringValue ? result : '';
        var error = {
            type: type,
            message: message,
            ref: ref,
        };
        nativeError(message);
        return error;
    }
    return;
}

var validateField = (function (_a, fields, nativeValidation) {
    var ref = _a.ref, _b = _a.ref, type = _b.type, value = _b.value, name = _b.name, checked = _b.checked, options = _a.options, required = _a.required, maxLength = _a.maxLength, minLength = _a.minLength, min = _a.min, max = _a.max, pattern = _a.pattern, validate = _a.validate;
    return __awaiter(void 0, void 0, void 0, function () {
        var error, isRadio, isCheckBox, nativeError, typedName, exceedMax, exceedMin, _c, maxValue, maxMessage, _d, minValue, minMessage, valueNumber, message, _e, maxLengthValue, maxLengthMessage, _f, minLengthValue, minLengthMessage, inputLength, exceedMax, exceedMin, message, _g, patternValue, patternMessage, fieldValue_1, validateRef_1, result, errorObject, validationResult;
        return __generator(this, function (_h) {
            switch (_h.label) {
                case 0:
                    error = {};
                    isRadio = isRadioInput(type);
                    isCheckBox = isCheckBoxInput(type);
                    nativeError = displayNativeError.bind(null, nativeValidation, ref);
                    typedName = name;
                    if (required &&
                        ((isCheckBox && !checked) ||
                            (!isCheckBox && !isRadio && value === '') ||
                            (isRadio && !getRadioValue(fields[typedName].options).isValid) ||
                            (type !== RADIO_INPUT && isNullOrUndefined(value)))) {
                        error[typedName] = {
                            type: REQUIRED_ATTRIBUTE,
                            message: isString(required) ? required : '',
                            ref: isRadio ? fields[typedName].options[0].ref : ref,
                        };
                        nativeError(required);
                        return [2 /*return*/, error];
                    }
                    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {
                        exceedMax = void 0;
                        exceedMin = void 0;
                        _c = getValueAndMessage(max), maxValue = _c.value, maxMessage = _c.message;
                        _d = getValueAndMessage(min), minValue = _d.value, minMessage = _d.message;
                        if (type === 'number') {
                            valueNumber = parseFloat(value);
                            if (!isNullOrUndefined(maxValue))
                                exceedMax = valueNumber > maxValue;
                            if (!isNullOrUndefined(minValue))
                                exceedMin = valueNumber < minValue;
                        }
                        else {
                            if (isString(maxValue))
                                exceedMax = new Date(value) > new Date(maxValue);
                            if (isString(minValue))
                                exceedMin = new Date(value) < new Date(minValue);
                        }
                        if (exceedMax || exceedMin) {
                            message = exceedMax ? maxMessage : minMessage;
                            error[typedName] = {
                                type: exceedMax ? 'max' : 'min',
                                message: message,
                                ref: ref,
                            };
                            nativeError(message);
                            return [2 /*return*/, error];
                        }
                    }
                    if ((maxLength || minLength) && isString(value)) {
                        _e = getValueAndMessage(maxLength), maxLengthValue = _e.value, maxLengthMessage = _e.message;
                        _f = getValueAndMessage(minLength), minLengthValue = _f.value, minLengthMessage = _f.message;
                        inputLength = value.toString().length;
                        exceedMax = maxLength && inputLength > maxLengthValue;
                        exceedMin = minLength && inputLength < minLengthValue;
                        if (exceedMax || exceedMin) {
                            message = exceedMax ? maxLengthMessage : minLengthMessage;
                            error[typedName] = {
                                type: exceedMax ? 'maxLength' : 'minLength',
                                message: message,
                                ref: ref,
                            };
                            nativeError(message);
                            return [2 /*return*/, error];
                        }
                    }
                    if (pattern) {
                        _g = getValueAndMessage(pattern), patternValue = _g.value, patternMessage = _g.message;
                        if (isRegex(patternValue) && !patternValue.test(value)) {
                            error[typedName] = {
                                type: PATTERN_ATTRIBUTE,
                                message: patternMessage,
                                ref: ref,
                            };
                            nativeError(patternMessage);
                            return [2 /*return*/, error];
                        }
                    }
                    if (!validate) return [3 /*break*/, 4];
                    fieldValue_1 = getFieldValue(fields, ref);
                    validateRef_1 = isRadio && options ? options[0].ref : ref;
                    if (!isFunction(validate)) return [3 /*break*/, 2];
                    return [4 /*yield*/, validate(fieldValue_1)];
                case 1:
                    result = _h.sent();
                    errorObject = getValidateFunctionErrorObject(result, validateRef_1, nativeError);
                    if (errorObject) {
                        error[typedName] = errorObject;
                        return [2 /*return*/, error];
                    }
                    return [3 /*break*/, 4];
                case 2:
                    if (!isObject(validate)) return [3 /*break*/, 4];
                    return [4 /*yield*/, new Promise(function (resolve) {
                            var values = Object.entries(validate);
                            values.reduce(function (previous, _a, index) {
                                var _b = __read(_a, 2), key = _b[0], validate = _b[1];
                                return __awaiter(void 0, void 0, void 0, function () {
                                    var lastChild, result, errorObject;
                                    return __generator(this, function (_c) {
                                        switch (_c.label) {
                                            case 0:
                                                lastChild = values.length - 1 === index;
                                                if (!isFunction(validate)) return [3 /*break*/, 2];
                                                return [4 /*yield*/, validate(fieldValue_1)];
                                            case 1:
                                                result = _c.sent();
                                                errorObject = getValidateFunctionErrorObject(result, validateRef_1, nativeError, key);
                                                if (errorObject) {
                                                    return [2 /*return*/, lastChild ? resolve(errorObject) : errorObject];
                                                }
                                                _c.label = 2;
                                            case 2: return [2 /*return*/, lastChild ? resolve(previous) : previous];
                                        }
                                    });
                                });
                            }, {});
                        })];
                case 3:
                    validationResult = _h.sent();
                    if (!isEmptyObject(validationResult)) {
                        error[typedName] = __assign({ ref: validateRef_1 }, validationResult);
                        return [2 /*return*/, error];
                    }
                    _h.label = 4;
                case 4:
                    if (nativeValidation)
                        ref.setCustomValidity('');
                    return [2 /*return*/, error];
            }
        });
    });
});

// TODO: Fix these types
var parseErrorSchema = function (error) {
    var _a;
    return error.inner.length
        ? error.inner.reduce(function (previous, _a) {
            var _b;
            var path = _a.path, message = _a.message, type = _a.type;
            return (__assign(__assign({}, previous), (_b = {}, _b[path] = { message: message, ref: {}, type: type }, _b)));
        }, {})
        : (_a = {},
            _a[error.path] = { message: error.message, ref: {}, type: error.type },
            _a);
};
function validateWithSchema(validationSchema, validationSchemaOption, data) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, e_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 2, , 3]);
                    _a = {};
                    return [4 /*yield*/, validationSchema.validate(data, validationSchemaOption)];
                case 1: return [2 /*return*/, (_a.result = _b.sent(),
                        _a.fieldErrors = {},
                        _a)];
                case 2:
                    e_1 = _b.sent();
                    return [2 /*return*/, {
                            result: {},
                            fieldErrors: parseErrorSchema(e_1),
                        }];
                case 3: return [2 /*return*/];
            }
        });
    });
}

function attachNativeValidation(ref, rules) {
    Object.entries(rules).forEach(function (_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        if (key === PATTERN_ATTRIBUTE && isRegex(value)) {
            ref[key] = value.source;
        }
        else {
            ref[key] = key === REQUIRED_ATTRIBUTE ? true : value;
        }
    });
}

var get = (function (obj, path, defaultValue) {
    var result = String.prototype.split
        .call(path, /[,[\].]+?/)
        .filter(Boolean)
        .reduce(function (res, key) { return (res !== null && res !== undefined ? res[key] : res); }, obj);
    return result === undefined || result === obj ? defaultValue : result;
});

var getDefaultValue = (function (defaultValues, name, defaultValue) {
    return isUndefined(defaultValues[name])
        ? get(defaultValues, name, defaultValue)
        : defaultValues[name];
});

function flatArray(list) {
    return list.reduce(function (a, b) { return a.concat(isArray(b) ? flatArray(b) : b); }, []);
}

var getPath = function (path, values) {
    return isArray(values)
        ? values.map(function (item, index) {
            var pathWithIndex = path + "[" + index + "]";
            if (isArray(item)) {
                return getPath(pathWithIndex, item);
            }
            else if (isObject(item)) {
                return Object.entries(item).map(function (_a) {
                    var _b = __read(_a, 2), key = _b[0], objectValue = _b[1];
                    return isString(objectValue)
                        ? pathWithIndex + "." + key
                        : getPath(pathWithIndex + "." + key, objectValue);
                });
            }
            return pathWithIndex;
        })
        : Object.entries(values).map(function (_a) {
            var _b = __read(_a, 2), key = _b[0], objectValue = _b[1];
            return isString(objectValue) ? path + "." + key : getPath(path, objectValue);
        });
};
var getPath$1 = (function (parentPath, value) { return flatArray(getPath(parentPath, value)); });

var assignWatchFields = (function (fieldValues, fieldName, watchFields) {
    if (isNullOrUndefined(fieldValues) || isEmptyObject(fieldValues))
        return undefined;
    if (!isUndefined(fieldValues[fieldName])) {
        watchFields[fieldName] = true;
        return fieldValues[fieldName];
    }
    var values = get(combineFieldValues(fieldValues), fieldName);
    if (!isUndefined(values)) {
        var result = getPath$1(fieldName, values);
        if (isArray(result)) {
            result.forEach(function (name) {
                watchFields[name] = true;
            });
        }
    }
    return values;
});

var omitValidFields = (function (errorFields, validFieldNames) {
    return Object.entries(errorFields).reduce(function (previous, _a) {
        var _b;
        var _c = __read(_a, 2), name = _c[0], error = _c[1];
        return validFieldNames.some(function (validFieldName) { return validFieldName === name; })
            ? previous
            : __assign(__assign({}, previous), (_b = {}, _b[name] = error, _b));
    }, {});
});

function onDomRemove(element, onDetachCallback) {
    var observer = new MutationObserver(function () {
        if (isDetached(element)) {
            observer.disconnect();
            onDetachCallback();
        }
    });
    observer.observe(window.document, {
        childList: true,
        subtree: true,
    });
    return observer;
}

var modeChecker = (function (mode) { return ({
    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
    isOnBlur: mode === VALIDATION_MODE.onBlur,
    isOnChange: mode === VALIDATION_MODE.onChange,
}); });

var pickErrors = (function (errors, pickList) {
    return Object.entries(errors).reduce(function (previous, _a) {
        var _b;
        var _c = __read(_a, 2), key = _c[0], error = _c[1];
        return (__assign(__assign({}, previous), (pickList.includes(key) ? (_b = {}, _b[key] = error, _b) : null)));
    }, {});
});

function useForm(_a) {
    var _this = this;
    var _b = _a === void 0 ? {} : _a, _c = _b.mode, mode = _c === void 0 ? VALIDATION_MODE.onSubmit : _c, _d = _b.reValidateMode, reValidateMode = _d === void 0 ? VALIDATION_MODE.onChange : _d, validationSchema = _b.validationSchema, _e = _b.defaultValues, defaultValues = _e === void 0 ? {} : _e, validationFields = _b.validationFields, nativeValidation = _b.nativeValidation, _f = _b.submitFocusError, submitFocusError = _f === void 0 ? true : _f, _g = _b.validationSchemaOption, validationSchemaOption = _g === void 0 ? { abortEarly: false } : _g;
    var fieldsRef = React.useRef({});
    var errorsRef = React.useRef({});
    var schemaErrorsRef = React.useRef({});
    var touchedFieldsRef = React.useRef(new Set());
    var watchFieldsRef = React.useRef({});
    var dirtyFieldsRef = React.useRef(new Set());
    var fieldsWithValidationRef = React.useRef(new Set());
    var validFieldsRef = React.useRef(new Set());
    var defaultValuesRef = React.useRef({});
    var isUnMount = React.useRef(false);
    var isWatchAllRef = React.useRef(false);
    var isSubmittedRef = React.useRef(false);
    var isDirtyRef = React.useRef(false);
    var submitCountRef = React.useRef(0);
    var isSubmittingRef = React.useRef(false);
    var isSchemaValidateTriggeredRef = React.useRef(false);
    var validationFieldsRef = React.useRef(validationFields);
    var validateAndUpdateStateRef = React.useRef();
    var _h = __read(React.useState(), 2), render = _h[1];
    var _j = React.useRef(modeChecker(mode)).current, isOnBlur = _j.isOnBlur, isOnSubmit = _j.isOnSubmit;
    var _k = React.useRef(modeChecker(reValidateMode)).current, isReValidateOnBlur = _k.isOnBlur, isReValidateOnSubmit = _k.isOnSubmit;
    var validationSchemaOptionRef = React.useRef(validationSchemaOption);
    validationFieldsRef.current = validationFields;
    var combineErrorsRef = function (data) { return (__assign(__assign({}, errorsRef.current), data)); };
    var renderBaseOnError = React.useCallback(function (name, error, shouldRender) {
        if (shouldRender === void 0) { shouldRender = true; }
        if (isEmptyObject(error)) {
            delete errorsRef.current[name];
            if (fieldsWithValidationRef.current.has(name) || validationSchema)
                validFieldsRef.current.add(name);
        }
        else {
            validFieldsRef.current.delete(name);
        }
        if (shouldRender)
            render({});
    }, [validationSchema]);
    var setFieldValue = function (name, rawValue) {
        var field = fieldsRef.current[name];
        if (!field)
            return false;
        var ref = field.ref;
        var type = ref.type;
        var options = field.options;
        var value = typeof document !== UNDEFINED &&
            typeof window !== UNDEFINED &&
            !isUndefined(window.HTMLElement) &&
            ref instanceof window.HTMLElement &&
            isNullOrUndefined(rawValue)
            ? ''
            : rawValue;
        if (isRadioInput(type) && options) {
            options.forEach(function (_a) {
                var radioRef = _a.ref;
                return (radioRef.checked = radioRef.value === value);
            });
        }
        else if (isMultipleSelect(type)) {
            __spread(ref.options).forEach(function (selectRef) {
                return (selectRef.selected = value.includes(selectRef.value));
            });
        }
        else {
            ref[isCheckBoxInput(type) ? 'checked' : 'value'] = value;
        }
        return type;
    };
    var setDirty = function (name) {
        if (!fieldsRef.current[name])
            return false;
        var isDirty = defaultValuesRef.current[name] !==
            getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);
        var isDirtyChanged = dirtyFieldsRef.current.has(name) !== isDirty;
        if (isDirty) {
            dirtyFieldsRef.current.add(name);
        }
        else {
            dirtyFieldsRef.current.delete(name);
        }
        isDirtyRef.current = !!dirtyFieldsRef.current.size;
        return isDirtyChanged;
    };
    var setValueInternal = React.useCallback(function (name, value) {
        var shouldRender = setFieldValue(name, value);
        if (setDirty(name) ||
            shouldRender ||
            !touchedFieldsRef.current.has(name)) {
            touchedFieldsRef.current.add(name);
            render({});
        }
    }, []);
    var executeValidation = React.useCallback(function (_a, shouldRender) {
        var name = _a.name, value = _a.value;
        if (shouldRender === void 0) { shouldRender = true; }
        return __awaiter(_this, void 0, void 0, function () {
            var field, error;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        field = fieldsRef.current[name];
                        if (!field)
                            return [2 /*return*/, false];
                        if (!isUndefined(value))
                            setValueInternal(name, value);
                        return [4 /*yield*/, validateField(field, fieldsRef.current)];
                    case 1:
                        error = _b.sent();
                        errorsRef.current = combineErrorsRef(error);
                        renderBaseOnError(name, error, shouldRender);
                        return [2 /*return*/, isEmptyObject(error)];
                }
            });
        });
    }, [renderBaseOnError, setValueInternal]);
    var validateWithSchemaCurry = React.useCallback(validateWithSchema.bind(null, validationSchema, validationSchemaOptionRef.current), [validationSchema]);
    var executeSchemaValidation = React.useCallback(function (payload) { return __awaiter(_this, void 0, void 0, function () {
        var fieldErrors, names, validFieldNames;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, validateWithSchemaCurry(combineFieldValues(getFieldsValues(fieldsRef.current)))];
                case 1:
                    fieldErrors = (_a.sent()).fieldErrors;
                    names = isArray(payload)
                        ? payload.map(function (_a) {
                            var name = _a.name;
                            return name;
                        })
                        : [payload.name];
                    validFieldNames = names.filter(function (name) { return !fieldErrors[name]; });
                    schemaErrorsRef.current = fieldErrors;
                    isSchemaValidateTriggeredRef.current = true;
                    errorsRef.current = omitValidFields(combineErrorsRef(Object.entries(fieldErrors)
                        .filter(function (_a) {
                        var _b = __read(_a, 1), key = _b[0];
                        return names.includes(key);
                    })
                        .reduce(function (previous, _a) {
                        var _b;
                        var _c = __read(_a, 2), name = _c[0], error = _c[1];
                        return (__assign(__assign({}, previous), (_b = {}, _b[name] = error, _b)));
                    }, {})), validFieldNames);
                    render({});
                    return [2 /*return*/, isEmptyObject(errorsRef.current)];
            }
        });
    }); }, [validateWithSchemaCurry]);
    var triggerValidation = React.useCallback(function (payload, shouldRender) { return __awaiter(_this, void 0, void 0, function () {
        var fields, result;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    fields = payload || Object.keys(fieldsRef.current).map(function (name) { return ({ name: name }); });
                    if (validationSchema)
                        return [2 /*return*/, executeSchemaValidation(fields)];
                    if (!isArray(fields)) return [3 /*break*/, 2];
                    return [4 /*yield*/, Promise.all(fields.map(function (data) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, executeValidation(data, false)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        }); }); }))];
                case 1:
                    result = _a.sent();
                    render({});
                    return [2 /*return*/, result.every(Boolean)];
                case 2: return [4 /*yield*/, executeValidation(fields, shouldRender)];
                case 3: return [2 /*return*/, _a.sent()];
            }
        });
    }); }, [executeSchemaValidation, executeValidation, validationSchema]);
    var setValue = React.useCallback(function (name, value, shouldValidate) {
        if (shouldValidate === void 0) { shouldValidate = false; }
        setValueInternal(name, value);
        var shouldRender = isWatchAllRef.current || watchFieldsRef.current[name];
        if (shouldValidate) {
            return triggerValidation({ name: name }, shouldRender);
        }
        if (shouldRender)
            render({});
        return;
    }, [setValueInternal, triggerValidation]);
    validateAndUpdateStateRef.current = validateAndUpdateStateRef.current
        ? validateAndUpdateStateRef.current
        : function (event) { return __awaiter(_this, void 0, void 0, function () {
            var type, target, name, fields, errors, ref, error, isBlurEvent, shouldSkipValidation, shouldUpdateDirty, shouldUpdateState, fieldErrors, shouldUpdate;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        type = event.type, target = event.target;
                        name = target ? target.name : '';
                        if (isArray(validationFieldsRef.current) &&
                            !validationFieldsRef.current.includes(name))
                            return [2 /*return*/];
                        fields = fieldsRef.current;
                        errors = errorsRef.current;
                        ref = fields[name];
                        if (!ref)
                            return [2 /*return*/];
                        isBlurEvent = type === EVENTS.BLUR;
                        shouldSkipValidation = (isOnSubmit && !isSubmittedRef.current) ||
                            (isOnBlur && !isBlurEvent && !errors[name]) ||
                            (isReValidateOnBlur && !isBlurEvent && errors[name]) ||
                            (isReValidateOnSubmit && errors[name]);
                        shouldUpdateDirty = setDirty(name);
                        shouldUpdateState = isWatchAllRef.current ||
                            watchFieldsRef.current[name] ||
                            shouldUpdateDirty;
                        if (!touchedFieldsRef.current.has(name)) {
                            touchedFieldsRef.current.add(name);
                            shouldUpdateState = true;
                        }
                        if (shouldSkipValidation)
                            return [2 /*return*/, shouldUpdateState ? render({}) : undefined];
                        if (!validationSchema) return [3 /*break*/, 2];
                        return [4 /*yield*/, validateWithSchemaCurry(combineFieldValues(getFieldsValues(fields)))];
                    case 1:
                        fieldErrors = (_b.sent()).fieldErrors;
                        schemaErrorsRef.current = fieldErrors;
                        isSchemaValidateTriggeredRef.current = true;
                        error = fieldErrors[name]
                            ? (_a = {}, _a[name] = fieldErrors[name], _a) : {};
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, validateField(ref, fields, nativeValidation)];
                    case 3:
                        error = _b.sent();
                        _b.label = 4;
                    case 4:
                        shouldUpdate = shouldUpdateWithError({
                            errors: errors,
                            error: error,
                            name: name,
                            validFields: validFieldsRef.current,
                            fieldsWithValidation: fieldsWithValidationRef.current,
                        });
                        if (shouldUpdate) {
                            errorsRef.current = combineErrorsRef(error);
                            renderBaseOnError(name, error);
                            return [2 /*return*/];
                        }
                        if (shouldUpdateState)
                            render({});
                        return [2 /*return*/];
                }
            });
        }); };
    var resetFieldRef = function (name) {
        delete watchFieldsRef.current[name];
        delete errorsRef.current[name];
        delete fieldsRef.current[name];
        delete defaultValuesRef.current[name];
        [
            touchedFieldsRef,
            dirtyFieldsRef,
            fieldsWithValidationRef,
            validFieldsRef,
        ].forEach(function (data) { return data.current.delete(name); });
    };
    var removeEventListenerAndRef = React.useCallback(function (field, forceDelete) {
        if (!field)
            return;
        findRemovedFieldAndRemoveListener(fieldsRef.current, validateAndUpdateStateRef.current, field, forceDelete);
        resetFieldRef(field.ref.name);
    }, []);
    function clearError(name) {
        if (isUndefined(name)) {
            errorsRef.current = {};
        }
        else {
            (isArray(name) ? name : [name]).forEach(function (fieldName) { return delete errorsRef.current[fieldName]; });
        }
        render({});
    }
    var setError = function (name, type, message, ref) {
        var errors = errorsRef.current;
        if (!isSameError(errors[name], type, message)) {
            errors[name] = {
                type: type,
                message: message,
                ref: ref,
                isManual: true,
            };
            render({});
        }
    };
    function watch(fieldNames, defaultValue) {
        var fieldValues = getFieldsValues(fieldsRef.current);
        var watchFields = watchFieldsRef.current;
        if (isString(fieldNames)) {
            var value = assignWatchFields(fieldValues, fieldNames, watchFields);
            return isUndefined(value)
                ? isUndefined(defaultValue)
                    ? getDefaultValue(defaultValues, fieldNames)
                    : defaultValue
                : value;
        }
        if (isArray(fieldNames)) {
            return fieldNames.reduce(function (previous, name) {
                var _a;
                var value = getDefaultValue(defaultValues, name);
                if (isEmptyObject(fieldsRef.current) && isObject(defaultValue)) {
                    value = defaultValue[name];
                }
                else {
                    var tempValue = assignWatchFields(fieldValues, name, watchFields);
                    if (!isUndefined(tempValue))
                        value = tempValue;
                }
                return __assign(__assign({}, previous), (_a = {}, _a[name] = value, _a));
            }, {});
        }
        isWatchAllRef.current = true;
        return ((!isEmptyObject(fieldValues) && fieldValues) ||
            defaultValue ||
            defaultValues);
    }
    function registerIntoFieldsRef(ref, validateOptions) {
        if (validateOptions === void 0) { validateOptions = {}; }
        if (!ref.name)
            return console.warn('Missing name on ref', ref);
        var name = ref.name, type = ref.type, value = ref.value;
        var typedName = name;
        var fieldAttributes = __assign({ ref: ref }, validateOptions);
        var fields = fieldsRef.current;
        var isRadio = isRadioInput(type);
        var currentField = (fields[typedName] || undefined);
        var isRegistered = isRadio
            ? currentField &&
                isArray(currentField.options) &&
                currentField.options.find(function (_a) {
                    var ref = _a.ref;
                    return value === ref.value;
                })
            : currentField;
        if (isRegistered)
            return;
        if (!type) {
            currentField = fieldAttributes;
        }
        else {
            var mutationWatcher = onDomRemove(ref, function () {
                return removeEventListenerAndRef(fieldAttributes);
            });
            if (isRadio) {
                currentField = __assign({ options: __spread((currentField && currentField.options
                        ? currentField.options
                        : []), [
                        {
                            ref: ref,
                            mutationWatcher: mutationWatcher,
                        },
                    ]), ref: { type: RADIO_INPUT, name: name } }, validateOptions);
            }
            else {
                currentField = __assign(__assign({}, fieldAttributes), { mutationWatcher: mutationWatcher });
            }
        }
        fields[typedName] = currentField;
        if (!isEmptyObject(defaultValues)) {
            var defaultValue = getDefaultValue(defaultValues, name);
            if (!isUndefined(defaultValue))
                setFieldValue(name, defaultValue);
        }
        if (validateOptions && !isEmptyObject(validateOptions)) {
            fieldsWithValidationRef.current.add(name);
            if (!isOnSubmit) {
                if (validationSchema) {
                    isSchemaValidateTriggeredRef.current = true;
                    validateWithSchemaCurry(combineFieldValues(getFieldsValues(fields))).then(function (_a) {
                        var fieldErrors = _a.fieldErrors;
                        schemaErrorsRef.current = fieldErrors;
                        if (isEmptyObject(schemaErrorsRef.current))
                            render({});
                    });
                }
                else {
                    validateField(currentField, fields).then(function (error) {
                        if (isEmptyObject(error))
                            validFieldsRef.current.add(name);
                        if (validFieldsRef.current.size ===
                            fieldsWithValidationRef.current.size)
                            render({});
                    });
                }
            }
        }
        if (!defaultValuesRef.current[typedName])
            defaultValuesRef.current[typedName] = getFieldValue(fields, currentField.ref);
        if (!type)
            return;
        var fieldToRegister = isRadio && currentField.options
            ? currentField.options[currentField.options.length - 1]
            : currentField;
        if (isOnSubmit && isReValidateOnSubmit)
            return;
        if (nativeValidation && validateOptions) {
            attachNativeValidation(ref, validateOptions);
        }
        else {
            attachEventListeners({
                field: fieldToRegister,
                isRadio: isRadio,
                validateAndStateUpdate: validateAndUpdateStateRef.current,
                isOnBlur: isOnBlur,
                isReValidateOnBlur: isReValidateOnBlur,
            });
        }
    }
    function register(refOrValidateRule, validationOptions) {
        if (typeof window === UNDEFINED || !refOrValidateRule)
            return;
        if (isObject(refOrValidateRule) &&
            (validationOptions || 'name' in refOrValidateRule)) {
            registerIntoFieldsRef(refOrValidateRule, validationOptions);
            return;
        }
        return function (ref) {
            return ref && registerIntoFieldsRef(ref, refOrValidateRule);
        };
    }
    function unregister(names) {
        if (isEmptyObject(fieldsRef.current))
            return;
        (isArray(names) ? names : [names]).forEach(function (fieldName) {
            return removeEventListenerAndRef(fieldsRef.current[fieldName], true);
        });
    }
    var handleSubmit = function (callback) { return function (e) { return __awaiter(_this, void 0, void 0, function () {
        var fieldErrors, fieldValues, fields, fieldsToValidate, output, _a, errors, values;
        var _this = this;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (e) {
                        e.preventDefault();
                        e.persist();
                    }
                    fields = fieldsRef.current;
                    fieldsToValidate = validationFields
                        ? validationFields.map(function (name) { return fieldsRef.current[name]; })
                        : Object.values(fields);
                    isSubmittingRef.current = true;
                    render({});
                    if (!validationSchema) return [3 /*break*/, 2];
                    fieldValues = getFieldsValues(fields);
                    return [4 /*yield*/, validateWithSchemaCurry(combineFieldValues(fieldValues))];
                case 1:
                    output = _b.sent();
                    schemaErrorsRef.current = output.fieldErrors;
                    fieldErrors = output.fieldErrors;
                    fieldValues = output.result;
                    return [3 /*break*/, 4];
                case 2: return [4 /*yield*/, fieldsToValidate.reduce(function (previous, field) { return __awaiter(_this, void 0, void 0, function () {
                        var resolvedPrevious, ref, name, fieldError;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!field)
                                        return [2 /*return*/, previous];
                                    return [4 /*yield*/, previous];
                                case 1:
                                    resolvedPrevious = _a.sent();
                                    ref = field.ref, name = field.ref.name;
                                    if (!fields[name])
                                        return [2 /*return*/, Promise.resolve(resolvedPrevious)];
                                    return [4 /*yield*/, validateField(field, fields, nativeValidation)];
                                case 2:
                                    fieldError = _a.sent();
                                    if (fieldError[name]) {
                                        resolvedPrevious.errors = __assign(__assign({}, resolvedPrevious.errors), fieldError);
                                        validFieldsRef.current.delete(name);
                                        return [2 /*return*/, Promise.resolve(resolvedPrevious)];
                                    }
                                    if (fieldsWithValidationRef.current.has(name))
                                        validFieldsRef.current.add(name);
                                    resolvedPrevious.values[name] = getFieldValue(fields, ref);
                                    return [2 /*return*/, Promise.resolve(resolvedPrevious)];
                            }
                        });
                    }); }, Promise.resolve({
                        errors: {},
                        values: {},
                    }))];
                case 3:
                    _a = _b.sent(), errors = _a.errors, values = _a.values;
                    fieldErrors = errors;
                    fieldValues = values;
                    _b.label = 4;
                case 4:
                    if (!isEmptyObject(fieldErrors)) return [3 /*break*/, 6];
                    errorsRef.current = {};
                    return [4 /*yield*/, callback(combineFieldValues(fieldValues), e)];
                case 5:
                    _b.sent();
                    return [3 /*break*/, 7];
                case 6:
                    if (submitFocusError) {
                        Object.keys(fieldErrors).reduce(function (previous, current) {
                            var field = fields[current];
                            if (field && field.ref.focus && previous) {
                                field.ref.focus();
                                return false;
                            }
                            return previous;
                        }, true);
                    }
                    errorsRef.current = fieldErrors;
                    _b.label = 7;
                case 7:
                    if (isUnMount.current)
                        return [2 /*return*/];
                    isSubmittedRef.current = true;
                    isSubmittingRef.current = false;
                    submitCountRef.current = submitCountRef.current + 1;
                    render({});
                    return [2 /*return*/];
            }
        });
    }); }; };
    var resetRefs = function () {
        errorsRef.current = {};
        schemaErrorsRef.current = {};
        touchedFieldsRef.current = new Set();
        watchFieldsRef.current = {};
        dirtyFieldsRef.current = new Set();
        fieldsWithValidationRef.current = new Set();
        validFieldsRef.current = new Set();
        defaultValuesRef.current = {};
        isWatchAllRef.current = false;
        isSubmittedRef.current = false;
        isDirtyRef.current = false;
        isSchemaValidateTriggeredRef.current = false;
    };
    var reset = React.useCallback(function (values) {
        var e_1, _a;
        var fieldsKeyValue = Object.entries(fieldsRef.current);
        try {
            for (var fieldsKeyValue_1 = __values(fieldsKeyValue), fieldsKeyValue_1_1 = fieldsKeyValue_1.next(); !fieldsKeyValue_1_1.done; fieldsKeyValue_1_1 = fieldsKeyValue_1.next()) {
                var _b = __read(fieldsKeyValue_1_1.value, 2), value = _b[1];
                if (value && value.ref && value.ref.closest) {
                    try {
                        value.ref.closest('form').reset();
                        break;
                    }
                    catch (_c) { }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (fieldsKeyValue_1_1 && !fieldsKeyValue_1_1.done && (_a = fieldsKeyValue_1.return)) _a.call(fieldsKeyValue_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        resetRefs();
        if (values) {
            fieldsKeyValue.forEach(function (_a) {
                var _b = __read(_a, 1), key = _b[0];
                return setFieldValue(key, getDefaultValue(values, key));
            });
            defaultValuesRef.current = __assign({}, values);
        }
        submitCountRef.current = 0;
        render({});
    }, []);
    var getValues = function (payload) {
        var fieldValues = getFieldsValues(fieldsRef.current);
        var output = payload && payload.nest ? combineFieldValues(fieldValues) : fieldValues;
        return isEmptyObject(output) ? defaultValues : output;
    };
    React.useEffect(function () { return function () {
        isUnMount.current = true;
        fieldsRef.current &&
            Object.values(fieldsRef.current).forEach(function (field) {
                return removeEventListenerAndRef(field, true);
            });
    }; }, [removeEventListenerAndRef]);
    return {
        register: React.useCallback(register, [registerIntoFieldsRef]),
        unregister: React.useCallback(unregister, [
            unregister,
            removeEventListenerAndRef,
        ]),
        handleSubmit: handleSubmit,
        watch: watch,
        reset: reset,
        clearError: clearError,
        setError: setError,
        setValue: setValue,
        triggerValidation: triggerValidation,
        getValues: getValues,
        errors: validationFields
            ? pickErrors(errorsRef.current, validationFields)
            : errorsRef.current,
        formState: __assign({ dirty: isDirtyRef.current, isSubmitted: isSubmittedRef.current, submitCount: submitCountRef.current, touched: __spread(touchedFieldsRef.current), isSubmitting: isSubmittingRef.current }, (isOnSubmit
            ? {
                isValid: isEmptyObject(errorsRef.current),
            }
            : {
                isValid: validationSchema
                    ? isSchemaValidateTriggeredRef.current &&
                        isEmptyObject(schemaErrorsRef.current)
                    : fieldsWithValidationRef.current.size
                        ? !isEmptyObject(fieldsRef.current) &&
                            validFieldsRef.current.size >=
                                fieldsWithValidationRef.current.size
                        : !isEmptyObject(fieldsRef.current),
            })),
    };
}

var FormGlobalContext = React.createContext(null);
function useFormContext() {
    return React.useContext(FormGlobalContext);
}
function FormContext(props) {
    var children = props.children, formState = props.formState, errors = props.errors, restMethods = __rest(props, ["children", "formState", "errors"]);
    var restRef = React.useRef(restMethods);
    return (React.createElement(FormGlobalContext.Provider, { value: __assign(__assign({}, restRef.current), { formState: formState, errors: errors }) }, children));
}

exports.FormContext = FormContext;
exports.default = useForm;
exports.useFormContext = useFormContext;
