{"ast":null,"code":"import _slicedToArray from \"/Users/raffi/github/nmtsa-hackathon/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { useRef, useState, useCallback, useEffect, createContext, useContext, createElement } from 'react';\n\nvar isCheckBoxInput = type => type === 'checkbox';\n\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit'\n};\nconst RADIO_INPUT = 'radio';\nconst REQUIRED_ATTRIBUTE = 'required';\nconst PATTERN_ATTRIBUTE = 'pattern';\nconst UNDEFINED = 'undefined';\nconst EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input'\n};\n\nfunction attachEventListeners({\n  field,\n  validateAndStateUpdate,\n  isRadio,\n  isOnBlur,\n  isReValidateOnBlur\n}) {\n  const ref = field.ref;\n  if (!ref.addEventListener) return;\n  ref.addEventListener(isCheckBoxInput(ref.type) || isRadio ? EVENTS.CHANGE : EVENTS.INPUT, validateAndStateUpdate);\n  if (isOnBlur || isReValidateOnBlur) ref.addEventListener(EVENTS.BLUR, validateAndStateUpdate);\n}\n\nvar isUndefined = val => val === undefined;\n\nvar isNullOrUndefined = value => value === null || isUndefined(value);\n\nvar isArray = value => Array.isArray(value);\n\nvar isObject = value => !isNullOrUndefined(value) && !isArray(value) && typeof value === 'object';\n\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\nconst rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst reIsUint = /^(?:0|[1-9]\\d*)$/;\n\nfunction isIndex(value) {\n  return reIsUint.test(value) && value > -1;\n}\n\nfunction isKey(value) {\n  if (isArray(value)) return false;\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value);\n}\n\nconst stringToPath = string => {\n  const result = [];\n  string.replace(rePropName, (match, number, quote, string) => {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);\n  });\n  return result;\n};\n\nfunction set(object, path, value) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) || isArray(objValue) ? objValue : isIndex(tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nvar combineFieldValues = data => Object.entries(data).reduce((previous, [key, value]) => {\n  if (!!key.match(/\\[.+\\]/gi) || key.indexOf('.') > 0) {\n    set(previous, key, value);\n    return previous;\n  }\n\n  return Object.assign(Object.assign({}, previous), {\n    [key]: value\n  });\n}, {});\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\n  if (!ref.removeEventListener) return;\n  ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n  ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n  ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n};\n\nvar isRadioInput = type => type === RADIO_INPUT;\n\nfunction isDetached(element) {\n  if (!element) return true;\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) return false;\n  return isDetached(element.parentNode);\n}\n\nfunction findRemovedFieldAndRemoveListener(fields, validateWithStateUpdate = () => {}, field, forceDelete = false) {\n  if (!field) return;\n  const ref = field.ref,\n        mutationWatcher = field.mutationWatcher,\n        options = field.options;\n  if (!ref || !ref.type) return;\n  const name = ref.name,\n        type = ref.type;\n\n  if (isRadioInput(type) && options) {\n    options.forEach(({\n      ref\n    }, index) => {\n      if (options[index] && isDetached(ref) || forceDelete) {\n        removeAllEventListeners(options[index], validateWithStateUpdate);\n        (options[index].mutationWatcher || {\n          disconnect: () => {}\n        }).disconnect();\n        options.splice(index, 1);\n      }\n    });\n    if (!options.length) delete fields[name];\n  } else if (isDetached(ref) || forceDelete) {\n    removeAllEventListeners(ref, validateWithStateUpdate);\n    if (mutationWatcher) mutationWatcher.disconnect();\n    delete fields[name];\n  }\n}\n\nconst defaultReturn = {\n  isValid: false,\n  value: ''\n};\n\nvar getRadioValue = options => isArray(options) ? options.reduce((previous, {\n  ref: {\n    checked,\n    value\n  }\n}) => checked ? {\n  isValid: true,\n  value\n} : previous, defaultReturn) : defaultReturn;\n\nvar getMultipleSelectValue = options => [...options].filter(({\n  selected\n}) => selected).map(({\n  value\n}) => value);\n\nvar isMultipleSelect = type => type === 'select-multiple';\n\nfunction getFieldValue(fields, ref) {\n  const type = ref.type,\n        name = ref.name,\n        options = ref.options,\n        checked = ref.checked,\n        value = ref.value,\n        files = ref.files;\n\n  if (type === 'file') {\n    return files;\n  }\n\n  if (isRadioInput(type)) {\n    const field = fields[name];\n    return field ? getRadioValue(field.options).value : '';\n  }\n\n  if (isMultipleSelect(type)) return getMultipleSelectValue(options);\n\n  if (isCheckBoxInput(type)) {\n    if (checked) {\n      return ref.attributes && ref.attributes.value ? isUndefined(value) || value === '' ? true : value : true;\n    }\n\n    return false;\n  }\n\n  return value;\n}\n\nvar getFieldsValues = fields => Object.values(fields).reduce((previous, {\n  ref,\n  ref: {\n    name\n  }\n}) => Object.assign(Object.assign({}, previous), {\n  [name]: getFieldValue(fields, ref)\n}), {});\n\nvar isEmptyObject = value => isObject(value) && Object.keys(value).length === 0;\n\nvar isSameError = (error, type, message) => isObject(error) && error.type === type && error.message === message; // TODO: improve the types in this file\n\n\nfunction shouldUpdateWithError({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation\n}) {\n  if (validFields.has(name) && isEmptyObject(error) || errors[name] && errors[name].isManual) {\n    return false;\n  }\n\n  if (fieldsWithValidation.has(name) && !validFields.has(name) && isEmptyObject(error) || isEmptyObject(errors) && !isEmptyObject(error) || isEmptyObject(error) && errors[name] || !errors[name]) {\n    return true;\n  }\n\n  return errors[name] && error[name] && !isSameError(errors[name], error[name].type, error[name].message);\n}\n\nvar isRegex = value => value instanceof RegExp;\n\nvar getValueAndMessage = validationData => ({\n  value: isObject(validationData) && !isRegex(validationData) ? validationData.value : validationData,\n  message: isObject(validationData) && !isRegex(validationData) ? validationData.message : ''\n});\n\nvar isString = value => typeof value === 'string';\n\nvar displayNativeError = (nativeValidation, ref, message) => {\n  if (nativeValidation && isString(message)) ref.setCustomValidity(message);\n};\n\nvar isFunction = value => typeof value === 'function';\n\nvar isBoolean = value => typeof value === 'boolean';\n\nfunction getValidateFunctionErrorObject(result, ref, nativeError, type = 'validate') {\n  const isStringValue = isString(result);\n\n  if (isStringValue || isBoolean(result) && !result) {\n    const message = isStringValue ? result : '';\n    const error = {\n      type,\n      message,\n      ref\n    };\n    nativeError(message);\n    return error;\n  }\n\n  return;\n}\n\nvar validateField = async ({\n  ref,\n  ref: {\n    type,\n    value,\n    name,\n    checked\n  },\n  options,\n  required,\n  maxLength,\n  minLength,\n  min,\n  max,\n  pattern,\n  validate\n}, fields, nativeValidation) => {\n  const error = {};\n  const isRadio = isRadioInput(type);\n  const isCheckBox = isCheckBoxInput(type);\n  const nativeError = displayNativeError.bind(null, nativeValidation, ref);\n  const typedName = name;\n\n  if (required && (isCheckBox && !checked || !isCheckBox && !isRadio && value === '' || isRadio && !getRadioValue(fields[typedName].options).isValid || type !== RADIO_INPUT && isNullOrUndefined(value))) {\n    error[typedName] = {\n      type: REQUIRED_ATTRIBUTE,\n      message: isString(required) ? required : '',\n      ref: isRadio ? fields[typedName].options[0].ref : ref\n    };\n    nativeError(required);\n    return error;\n  }\n\n  if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\n    let exceedMax;\n    let exceedMin;\n\n    const _getValueAndMessage = getValueAndMessage(max),\n          maxValue = _getValueAndMessage.value,\n          maxMessage = _getValueAndMessage.message;\n\n    const _getValueAndMessage2 = getValueAndMessage(min),\n          minValue = _getValueAndMessage2.value,\n          minMessage = _getValueAndMessage2.message;\n\n    if (type === 'number') {\n      const valueNumber = parseFloat(value);\n      if (!isNullOrUndefined(maxValue)) exceedMax = valueNumber > maxValue;\n      if (!isNullOrUndefined(minValue)) exceedMin = valueNumber < minValue;\n    } else {\n      if (isString(maxValue)) exceedMax = new Date(value) > new Date(maxValue);\n      if (isString(minValue)) exceedMin = new Date(value) < new Date(minValue);\n    }\n\n    if (exceedMax || exceedMin) {\n      const message = exceedMax ? maxMessage : minMessage;\n      error[typedName] = {\n        type: exceedMax ? 'max' : 'min',\n        message,\n        ref\n      };\n      nativeError(message);\n      return error;\n    }\n  }\n\n  if ((maxLength || minLength) && isString(value)) {\n    const _getValueAndMessage3 = getValueAndMessage(maxLength),\n          maxLengthValue = _getValueAndMessage3.value,\n          maxLengthMessage = _getValueAndMessage3.message;\n\n    const _getValueAndMessage4 = getValueAndMessage(minLength),\n          minLengthValue = _getValueAndMessage4.value,\n          minLengthMessage = _getValueAndMessage4.message;\n\n    const inputLength = value.toString().length;\n    const exceedMax = maxLength && inputLength > maxLengthValue;\n    const exceedMin = minLength && inputLength < minLengthValue;\n\n    if (exceedMax || exceedMin) {\n      const message = exceedMax ? maxLengthMessage : minLengthMessage;\n      error[typedName] = {\n        type: exceedMax ? 'maxLength' : 'minLength',\n        message,\n        ref\n      };\n      nativeError(message);\n      return error;\n    }\n  }\n\n  if (pattern) {\n    const _getValueAndMessage5 = getValueAndMessage(pattern),\n          patternValue = _getValueAndMessage5.value,\n          patternMessage = _getValueAndMessage5.message;\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[typedName] = {\n        type: PATTERN_ATTRIBUTE,\n        message: patternMessage,\n        ref\n      };\n      nativeError(patternMessage);\n      return error;\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldValue(fields, ref);\n    const validateRef = isRadio && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const errorObject = getValidateFunctionErrorObject(result, validateRef, nativeError);\n\n      if (errorObject) {\n        error[typedName] = errorObject;\n        return error;\n      }\n    } else if (isObject(validate)) {\n      const validationResult = await new Promise(resolve => {\n        const values = Object.entries(validate);\n        values.reduce(async (previous, [key, validate], index) => {\n          const lastChild = values.length - 1 === index;\n\n          if (isFunction(validate)) {\n            const result = await validate(fieldValue);\n            const errorObject = getValidateFunctionErrorObject(result, validateRef, nativeError, key);\n\n            if (errorObject) {\n              return lastChild ? resolve(errorObject) : errorObject;\n            }\n          }\n\n          return lastChild ? resolve(previous) : previous;\n        }, {});\n      });\n\n      if (!isEmptyObject(validationResult)) {\n        error[typedName] = Object.assign({\n          ref: validateRef\n        }, validationResult);\n        return error;\n      }\n    }\n  }\n\n  if (nativeValidation) ref.setCustomValidity('');\n  return error;\n}; // TODO: Fix these types\n\n\nconst parseErrorSchema = error => error.inner.length ? error.inner.reduce((previous, {\n  path,\n  message,\n  type\n}) => Object.assign(Object.assign({}, previous), {\n  [path]: {\n    message,\n    ref: {},\n    type\n  }\n}), {}) : {\n  [error.path]: {\n    message: error.message,\n    ref: {},\n    type: error.type\n  }\n};\n\nasync function validateWithSchema(validationSchema, validationSchemaOption, data) {\n  try {\n    return {\n      result: await validationSchema.validate(data, validationSchemaOption),\n      fieldErrors: {}\n    };\n  } catch (e) {\n    return {\n      result: {},\n      fieldErrors: parseErrorSchema(e)\n    };\n  }\n}\n\nfunction attachNativeValidation(ref, rules) {\n  Object.entries(rules).forEach(([key, value]) => {\n    if (key === PATTERN_ATTRIBUTE && isRegex(value)) {\n      ref[key] = value.source;\n    } else {\n      ref[key] = key === REQUIRED_ATTRIBUTE ? true : value;\n    }\n  });\n}\n\nvar get = (obj, path, defaultValue) => {\n  const result = String.prototype.split.call(path, /[,[\\].]+?/).filter(Boolean).reduce((res, key) => res !== null && res !== undefined ? res[key] : res, obj);\n  return result === undefined || result === obj ? defaultValue : result;\n};\n\nvar getDefaultValue = (defaultValues, name, defaultValue) => isUndefined(defaultValues[name]) ? get(defaultValues, name, defaultValue) : defaultValues[name];\n\nfunction flatArray(list) {\n  return list.reduce((a, b) => a.concat(isArray(b) ? flatArray(b) : b), []);\n}\n\nconst getPath = (path, values) => isArray(values) ? values.map((item, index) => {\n  const pathWithIndex = \"\".concat(path, \"[\").concat(index, \"]\");\n\n  if (isArray(item)) {\n    return getPath(pathWithIndex, item);\n  } else if (isObject(item)) {\n    return Object.entries(item).map(([key, objectValue]) => isString(objectValue) ? \"\".concat(pathWithIndex, \".\").concat(key) : getPath(\"\".concat(pathWithIndex, \".\").concat(key), objectValue));\n  }\n\n  return pathWithIndex;\n}) : Object.entries(values).map(([key, objectValue]) => isString(objectValue) ? \"\".concat(path, \".\").concat(key) : getPath(path, objectValue));\n\nvar getPath$1 = (parentPath, value) => flatArray(getPath(parentPath, value));\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields) => {\n  if (isNullOrUndefined(fieldValues) || isEmptyObject(fieldValues)) return undefined;\n\n  if (!isUndefined(fieldValues[fieldName])) {\n    watchFields[fieldName] = true;\n    return fieldValues[fieldName];\n  }\n\n  const values = get(combineFieldValues(fieldValues), fieldName);\n\n  if (!isUndefined(values)) {\n    const result = getPath$1(fieldName, values);\n\n    if (isArray(result)) {\n      result.forEach(name => {\n        watchFields[name] = true;\n      });\n    }\n  }\n\n  return values;\n};\n\nvar omitValidFields = (errorFields, validFieldNames) => Object.entries(errorFields).reduce((previous, [name, error]) => validFieldNames.some(validFieldName => validFieldName === name) ? previous : Object.assign(Object.assign({}, previous), {\n  [name]: error\n}), {});\n\nfunction onDomRemove(element, onDetachCallback) {\n  const observer = new MutationObserver(() => {\n    if (isDetached(element)) {\n      observer.disconnect();\n      onDetachCallback();\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nvar modeChecker = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange\n});\n\nvar pickErrors = (errors, pickList) => Object.entries(errors).reduce((previous, [key, error]) => Object.assign(Object.assign({}, previous), pickList.includes(key) ? {\n  [key]: error\n} : null), {});\n\nfunction useForm({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  validationSchema,\n  defaultValues = {},\n  validationFields,\n  nativeValidation,\n  submitFocusError = true,\n  validationSchemaOption = {\n    abortEarly: false\n  }\n} = {}) {\n  const fieldsRef = useRef({});\n  const errorsRef = useRef({});\n  const schemaErrorsRef = useRef({});\n  const touchedFieldsRef = useRef(new Set());\n  const watchFieldsRef = useRef({});\n  const dirtyFieldsRef = useRef(new Set());\n  const fieldsWithValidationRef = useRef(new Set());\n  const validFieldsRef = useRef(new Set());\n  const defaultValuesRef = useRef({});\n  const isUnMount = useRef(false);\n  const isWatchAllRef = useRef(false);\n  const isSubmittedRef = useRef(false);\n  const isDirtyRef = useRef(false);\n  const submitCountRef = useRef(0);\n  const isSubmittingRef = useRef(false);\n  const isSchemaValidateTriggeredRef = useRef(false);\n  const validationFieldsRef = useRef(validationFields);\n  const validateAndUpdateStateRef = useRef();\n\n  const _useState = useState(),\n        _useState2 = _slicedToArray(_useState, 2),\n        render = _useState2[1];\n\n  const _useRef$current = useRef(modeChecker(mode)).current,\n        isOnBlur = _useRef$current.isOnBlur,\n        isOnSubmit = _useRef$current.isOnSubmit;\n  const _useRef$current2 = useRef(modeChecker(reValidateMode)).current,\n        isReValidateOnBlur = _useRef$current2.isOnBlur,\n        isReValidateOnSubmit = _useRef$current2.isOnSubmit;\n  const validationSchemaOptionRef = useRef(validationSchemaOption);\n  validationFieldsRef.current = validationFields;\n\n  const combineErrorsRef = data => Object.assign(Object.assign({}, errorsRef.current), data);\n\n  const renderBaseOnError = useCallback((name, error, shouldRender = true) => {\n    if (isEmptyObject(error)) {\n      delete errorsRef.current[name];\n      if (fieldsWithValidationRef.current.has(name) || validationSchema) validFieldsRef.current.add(name);\n    } else {\n      validFieldsRef.current.delete(name);\n    }\n\n    if (shouldRender) render({});\n  }, [validationSchema]);\n\n  const setFieldValue = (name, rawValue) => {\n    const field = fieldsRef.current[name];\n    if (!field) return false;\n    const ref = field.ref;\n    const type = ref.type;\n    const options = field.options;\n    const value = typeof document !== UNDEFINED && typeof window !== UNDEFINED && !isUndefined(window.HTMLElement) && ref instanceof window.HTMLElement && isNullOrUndefined(rawValue) ? '' : rawValue;\n\n    if (isRadioInput(type) && options) {\n      options.forEach(({\n        ref: radioRef\n      }) => radioRef.checked = radioRef.value === value);\n    } else if (isMultipleSelect(type)) {\n      [...ref.options].forEach(selectRef => selectRef.selected = value.includes(selectRef.value));\n    } else {\n      ref[isCheckBoxInput(type) ? 'checked' : 'value'] = value;\n    }\n\n    return type;\n  };\n\n  const setDirty = name => {\n    if (!fieldsRef.current[name]) return false;\n    const isDirty = defaultValuesRef.current[name] !== getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);\n    const isDirtyChanged = dirtyFieldsRef.current.has(name) !== isDirty;\n\n    if (isDirty) {\n      dirtyFieldsRef.current.add(name);\n    } else {\n      dirtyFieldsRef.current.delete(name);\n    }\n\n    isDirtyRef.current = !!dirtyFieldsRef.current.size;\n    return isDirtyChanged;\n  };\n\n  const setValueInternal = useCallback((name, value) => {\n    const shouldRender = setFieldValue(name, value);\n\n    if (setDirty(name) || shouldRender || !touchedFieldsRef.current.has(name)) {\n      touchedFieldsRef.current.add(name);\n      render({});\n    }\n  }, []);\n  const executeValidation = useCallback(async ({\n    name,\n    value\n  }, shouldRender = true) => {\n    const field = fieldsRef.current[name];\n    if (!field) return false;\n    if (!isUndefined(value)) setValueInternal(name, value);\n    const error = await validateField(field, fieldsRef.current);\n    errorsRef.current = combineErrorsRef(error);\n    renderBaseOnError(name, error, shouldRender);\n    return isEmptyObject(error);\n  }, [renderBaseOnError, setValueInternal]);\n  const validateWithSchemaCurry = useCallback(validateWithSchema.bind(null, validationSchema, validationSchemaOptionRef.current), [validationSchema]);\n  const executeSchemaValidation = useCallback(async payload => {\n    const _ref = await validateWithSchemaCurry(combineFieldValues(getFieldsValues(fieldsRef.current))),\n          fieldErrors = _ref.fieldErrors;\n\n    const names = isArray(payload) ? payload.map(({\n      name\n    }) => name) : [payload.name];\n    const validFieldNames = names.filter(name => !fieldErrors[name]);\n    schemaErrorsRef.current = fieldErrors;\n    isSchemaValidateTriggeredRef.current = true;\n    errorsRef.current = omitValidFields(combineErrorsRef(Object.entries(fieldErrors).filter(([key]) => names.includes(key)).reduce((previous, [name, error]) => Object.assign(Object.assign({}, previous), {\n      [name]: error\n    }), {})), validFieldNames);\n    render({});\n    return isEmptyObject(errorsRef.current);\n  }, [validateWithSchemaCurry]);\n  const triggerValidation = useCallback(async (payload, shouldRender) => {\n    const fields = payload || Object.keys(fieldsRef.current).map(name => ({\n      name\n    }));\n    if (validationSchema) return executeSchemaValidation(fields);\n\n    if (isArray(fields)) {\n      const result = await Promise.all(fields.map(async data => await executeValidation(data, false)));\n      render({});\n      return result.every(Boolean);\n    }\n\n    return await executeValidation(fields, shouldRender);\n  }, [executeSchemaValidation, executeValidation, validationSchema]);\n  const setValue = useCallback((name, value, shouldValidate = false) => {\n    setValueInternal(name, value);\n    const shouldRender = isWatchAllRef.current || watchFieldsRef.current[name];\n\n    if (shouldValidate) {\n      return triggerValidation({\n        name\n      }, shouldRender);\n    }\n\n    if (shouldRender) render({});\n    return;\n  }, [setValueInternal, triggerValidation]);\n  validateAndUpdateStateRef.current = validateAndUpdateStateRef.current ? validateAndUpdateStateRef.current : async event => {\n    const type = event.type,\n          target = event.target;\n    const name = target ? target.name : '';\n    if (isArray(validationFieldsRef.current) && !validationFieldsRef.current.includes(name)) return;\n    const fields = fieldsRef.current;\n    const errors = errorsRef.current;\n    const ref = fields[name];\n    let error;\n    if (!ref) return;\n    const isBlurEvent = type === EVENTS.BLUR;\n    const shouldSkipValidation = isOnSubmit && !isSubmittedRef.current || isOnBlur && !isBlurEvent && !errors[name] || isReValidateOnBlur && !isBlurEvent && errors[name] || isReValidateOnSubmit && errors[name];\n    const shouldUpdateDirty = setDirty(name);\n    let shouldUpdateState = isWatchAllRef.current || watchFieldsRef.current[name] || shouldUpdateDirty;\n\n    if (!touchedFieldsRef.current.has(name)) {\n      touchedFieldsRef.current.add(name);\n      shouldUpdateState = true;\n    }\n\n    if (shouldSkipValidation) return shouldUpdateState ? render({}) : undefined;\n\n    if (validationSchema) {\n      const _ref2 = await validateWithSchemaCurry(combineFieldValues(getFieldsValues(fields))),\n            fieldErrors = _ref2.fieldErrors;\n\n      schemaErrorsRef.current = fieldErrors;\n      isSchemaValidateTriggeredRef.current = true;\n      error = fieldErrors[name] ? {\n        [name]: fieldErrors[name]\n      } : {};\n    } else {\n      error = await validateField(ref, fields, nativeValidation);\n    }\n\n    const shouldUpdate = shouldUpdateWithError({\n      errors,\n      error,\n      name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n\n    if (shouldUpdate) {\n      errorsRef.current = combineErrorsRef(error);\n      renderBaseOnError(name, error);\n      return;\n    }\n\n    if (shouldUpdateState) render({});\n  };\n\n  const resetFieldRef = name => {\n    delete watchFieldsRef.current[name];\n    delete errorsRef.current[name];\n    delete fieldsRef.current[name];\n    delete defaultValuesRef.current[name];\n    [touchedFieldsRef, dirtyFieldsRef, fieldsWithValidationRef, validFieldsRef].forEach(data => data.current.delete(name));\n  };\n\n  const removeEventListenerAndRef = useCallback((field, forceDelete) => {\n    if (!field) return;\n    findRemovedFieldAndRemoveListener(fieldsRef.current, validateAndUpdateStateRef.current, field, forceDelete);\n    resetFieldRef(field.ref.name);\n  }, []);\n\n  function clearError(name) {\n    if (isUndefined(name)) {\n      errorsRef.current = {};\n    } else {\n      (isArray(name) ? name : [name]).forEach(fieldName => delete errorsRef.current[fieldName]);\n    }\n\n    render({});\n  }\n\n  const setError = (name, type, message, ref) => {\n    const errors = errorsRef.current;\n\n    if (!isSameError(errors[name], type, message)) {\n      errors[name] = {\n        type,\n        message,\n        ref,\n        isManual: true\n      };\n      render({});\n    }\n  };\n\n  function watch(fieldNames, defaultValue) {\n    const fieldValues = getFieldsValues(fieldsRef.current);\n    const watchFields = watchFieldsRef.current;\n\n    if (isString(fieldNames)) {\n      const value = assignWatchFields(fieldValues, fieldNames, watchFields);\n      return isUndefined(value) ? isUndefined(defaultValue) ? getDefaultValue(defaultValues, fieldNames) : defaultValue : value;\n    }\n\n    if (isArray(fieldNames)) {\n      return fieldNames.reduce((previous, name) => {\n        let value = getDefaultValue(defaultValues, name);\n\n        if (isEmptyObject(fieldsRef.current) && isObject(defaultValue)) {\n          value = defaultValue[name];\n        } else {\n          const tempValue = assignWatchFields(fieldValues, name, watchFields);\n          if (!isUndefined(tempValue)) value = tempValue;\n        }\n\n        return Object.assign(Object.assign({}, previous), {\n          [name]: value\n        });\n      }, {});\n    }\n\n    isWatchAllRef.current = true;\n    return !isEmptyObject(fieldValues) && fieldValues || defaultValue || defaultValues;\n  }\n\n  function registerIntoFieldsRef(ref, validateOptions = {}) {\n    if (!ref.name) return console.warn('Missing name on ref', ref);\n    const name = ref.name,\n          type = ref.type,\n          value = ref.value;\n    const typedName = name;\n    const fieldAttributes = Object.assign({\n      ref\n    }, validateOptions);\n    const fields = fieldsRef.current;\n    const isRadio = isRadioInput(type);\n    let currentField = fields[typedName] || undefined;\n    const isRegistered = isRadio ? currentField && isArray(currentField.options) && currentField.options.find(({\n      ref\n    }) => value === ref.value) : currentField;\n    if (isRegistered) return;\n\n    if (!type) {\n      currentField = fieldAttributes;\n    } else {\n      const mutationWatcher = onDomRemove(ref, () => removeEventListenerAndRef(fieldAttributes));\n\n      if (isRadio) {\n        currentField = Object.assign({\n          options: [...(currentField && currentField.options ? currentField.options : []), {\n            ref,\n            mutationWatcher\n          }],\n          ref: {\n            type: RADIO_INPUT,\n            name\n          }\n        }, validateOptions);\n      } else {\n        currentField = Object.assign(Object.assign({}, fieldAttributes), {\n          mutationWatcher\n        });\n      }\n    }\n\n    fields[typedName] = currentField;\n\n    if (!isEmptyObject(defaultValues)) {\n      const defaultValue = getDefaultValue(defaultValues, name);\n      if (!isUndefined(defaultValue)) setFieldValue(name, defaultValue);\n    }\n\n    if (validateOptions && !isEmptyObject(validateOptions)) {\n      fieldsWithValidationRef.current.add(name);\n\n      if (!isOnSubmit) {\n        if (validationSchema) {\n          isSchemaValidateTriggeredRef.current = true;\n          validateWithSchemaCurry(combineFieldValues(getFieldsValues(fields))).then(({\n            fieldErrors\n          }) => {\n            schemaErrorsRef.current = fieldErrors;\n            if (isEmptyObject(schemaErrorsRef.current)) render({});\n          });\n        } else {\n          validateField(currentField, fields).then(error => {\n            if (isEmptyObject(error)) validFieldsRef.current.add(name);\n            if (validFieldsRef.current.size === fieldsWithValidationRef.current.size) render({});\n          });\n        }\n      }\n    }\n\n    if (!defaultValuesRef.current[typedName]) defaultValuesRef.current[typedName] = getFieldValue(fields, currentField.ref);\n    if (!type) return;\n    const fieldToRegister = isRadio && currentField.options ? currentField.options[currentField.options.length - 1] : currentField;\n    if (isOnSubmit && isReValidateOnSubmit) return;\n\n    if (nativeValidation && validateOptions) {\n      attachNativeValidation(ref, validateOptions);\n    } else {\n      attachEventListeners({\n        field: fieldToRegister,\n        isRadio,\n        validateAndStateUpdate: validateAndUpdateStateRef.current,\n        isOnBlur,\n        isReValidateOnBlur\n      });\n    }\n  }\n\n  function register(refOrValidateRule, validationOptions) {\n    if (typeof window === UNDEFINED || !refOrValidateRule) return;\n\n    if (isObject(refOrValidateRule) && (validationOptions || 'name' in refOrValidateRule)) {\n      registerIntoFieldsRef(refOrValidateRule, validationOptions);\n      return;\n    }\n\n    return ref => ref && registerIntoFieldsRef(ref, refOrValidateRule);\n  }\n\n  function unregister(names) {\n    if (isEmptyObject(fieldsRef.current)) return;\n    (isArray(names) ? names : [names]).forEach(fieldName => removeEventListenerAndRef(fieldsRef.current[fieldName], true));\n  }\n\n  const handleSubmit = callback => async e => {\n    if (e) {\n      e.preventDefault();\n      e.persist();\n    }\n\n    let fieldErrors;\n    let fieldValues;\n    const fields = fieldsRef.current;\n    const fieldsToValidate = validationFields ? validationFields.map(name => fieldsRef.current[name]) : Object.values(fields);\n    isSubmittingRef.current = true;\n    render({});\n\n    if (validationSchema) {\n      fieldValues = getFieldsValues(fields);\n      const output = await validateWithSchemaCurry(combineFieldValues(fieldValues));\n      schemaErrorsRef.current = output.fieldErrors;\n      fieldErrors = output.fieldErrors;\n      fieldValues = output.result;\n    } else {\n      const _ref3 = await fieldsToValidate.reduce(async (previous, field) => {\n        if (!field) return previous;\n        const resolvedPrevious = await previous;\n        const ref = field.ref,\n              name = field.ref.name;\n        if (!fields[name]) return Promise.resolve(resolvedPrevious);\n        const fieldError = await validateField(field, fields, nativeValidation);\n\n        if (fieldError[name]) {\n          resolvedPrevious.errors = Object.assign(Object.assign({}, resolvedPrevious.errors), fieldError);\n          validFieldsRef.current.delete(name);\n          return Promise.resolve(resolvedPrevious);\n        }\n\n        if (fieldsWithValidationRef.current.has(name)) validFieldsRef.current.add(name);\n        resolvedPrevious.values[name] = getFieldValue(fields, ref);\n        return Promise.resolve(resolvedPrevious);\n      }, Promise.resolve({\n        errors: {},\n        values: {}\n      })),\n            errors = _ref3.errors,\n            values = _ref3.values;\n\n      fieldErrors = errors;\n      fieldValues = values;\n    }\n\n    if (isEmptyObject(fieldErrors)) {\n      errorsRef.current = {};\n      await callback(combineFieldValues(fieldValues), e);\n    } else {\n      if (submitFocusError) {\n        Object.keys(fieldErrors).reduce((previous, current) => {\n          const field = fields[current];\n\n          if (field && field.ref.focus && previous) {\n            field.ref.focus();\n            return false;\n          }\n\n          return previous;\n        }, true);\n      }\n\n      errorsRef.current = fieldErrors;\n    }\n\n    if (isUnMount.current) return;\n    isSubmittedRef.current = true;\n    isSubmittingRef.current = false;\n    submitCountRef.current = submitCountRef.current + 1;\n    render({});\n  };\n\n  const resetRefs = () => {\n    errorsRef.current = {};\n    schemaErrorsRef.current = {};\n    touchedFieldsRef.current = new Set();\n    watchFieldsRef.current = {};\n    dirtyFieldsRef.current = new Set();\n    fieldsWithValidationRef.current = new Set();\n    validFieldsRef.current = new Set();\n    defaultValuesRef.current = {};\n    isWatchAllRef.current = false;\n    isSubmittedRef.current = false;\n    isDirtyRef.current = false;\n    isSchemaValidateTriggeredRef.current = false;\n  };\n\n  const reset = useCallback(values => {\n    const fieldsKeyValue = Object.entries(fieldsRef.current);\n\n    for (let _ref4 of fieldsKeyValue) {\n      var _ref5 = _slicedToArray(_ref4, 2);\n\n      let value = _ref5[1];\n\n      if (value && value.ref && value.ref.closest) {\n        try {\n          value.ref.closest('form').reset();\n          break;\n        } catch (_a) {}\n      }\n    }\n\n    resetRefs();\n\n    if (values) {\n      fieldsKeyValue.forEach(([key]) => setFieldValue(key, getDefaultValue(values, key)));\n      defaultValuesRef.current = Object.assign({}, values);\n    }\n\n    submitCountRef.current = 0;\n    render({});\n  }, []);\n\n  const getValues = payload => {\n    const fieldValues = getFieldsValues(fieldsRef.current);\n    const output = payload && payload.nest ? combineFieldValues(fieldValues) : fieldValues;\n    return isEmptyObject(output) ? defaultValues : output;\n  };\n\n  useEffect(() => () => {\n    isUnMount.current = true;\n    fieldsRef.current && Object.values(fieldsRef.current).forEach(field => removeEventListenerAndRef(field, true));\n  }, [removeEventListenerAndRef]);\n  return {\n    register: useCallback(register, [registerIntoFieldsRef]),\n    unregister: useCallback(unregister, [unregister, removeEventListenerAndRef]),\n    handleSubmit,\n    watch,\n    reset,\n    clearError,\n    setError,\n    setValue,\n    triggerValidation,\n    getValues,\n    errors: validationFields ? pickErrors(errorsRef.current, validationFields) : errorsRef.current,\n    formState: Object.assign({\n      dirty: isDirtyRef.current,\n      isSubmitted: isSubmittedRef.current,\n      submitCount: submitCountRef.current,\n      touched: [...touchedFieldsRef.current],\n      isSubmitting: isSubmittingRef.current\n    }, isOnSubmit ? {\n      isValid: isEmptyObject(errorsRef.current)\n    } : {\n      isValid: validationSchema ? isSchemaValidateTriggeredRef.current && isEmptyObject(schemaErrorsRef.current) : fieldsWithValidationRef.current.size ? !isEmptyObject(fieldsRef.current) && validFieldsRef.current.size >= fieldsWithValidationRef.current.size : !isEmptyObject(fieldsRef.current)\n    })\n  };\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nconst FormGlobalContext = createContext(null);\n\nfunction useFormContext() {\n  return useContext(FormGlobalContext);\n}\n\nfunction FormContext(props) {\n  const children = props.children,\n        formState = props.formState,\n        errors = props.errors,\n        restMethods = __rest(props, [\"children\", \"formState\", \"errors\"]);\n\n  const restRef = useRef(restMethods);\n  return createElement(FormGlobalContext.Provider, {\n    value: Object.assign(Object.assign({}, restRef.current), {\n      formState,\n      errors\n    })\n  }, children);\n}\n\nexport default useForm;\nexport { FormContext, useFormContext };","map":null,"metadata":{},"sourceType":"module"}